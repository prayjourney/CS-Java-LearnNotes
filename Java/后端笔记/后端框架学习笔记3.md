### 后端框架学习笔记3

***

[TOC]



##### 78 : mysql中decimal,numeric,double,float的区别
A : 区别如下
###### 显著区别
decimal,numeric属于**标准数据**类型, 指定精度和刻度；decimal的存储大小不确定, numeric的存储大小默认8个字节. 
double,float属于**非标准**数据类型, 在DB中保存的是近似值, **Decimal则以字符串的形式保存数值**. 


###### 比较
浮点数有个坏处, 当你给定的数据是整数的时候, 那么它就以整数给你处理. 这样我们在存取货币值的时候自然遇到问题, 我的default值为：0.00而实际存储是0, 同样我存取货币为12.00, 实际存储是12. 丢失了精度,变成了一个近似值.
Float数值类型用于表示单精度浮点数值, 而Double数值类型用于表示双精度浮点数值, Float和Double都是浮点型, 而Decimal是定点型；MySQL 浮点型和定点型可以用类型名称后加（M, D）来表示, M表示该值的总共长度, D表示小数点后面的长度, M和D又称为精度和标度, 
如float(7,4)的 可显示为-999.9999, MySQL保存值时进行四舍五入, 如果插入999.00009, 则结果为999.0001. 
Float和Double在不指 定精度时, 默认会按照实际的精度来显示, 而Decimal在不指定精度时, 默认整数为10, 小数为0. 同时, 对数据求SUM()时会出现不同的结果, Float和Double求SUM都会出现很多小数点, 而Decimal求SUM得到的是精准数值. decimal 和 numeric 是同义, 都是用于精确存储数值 . 

###### 使用小结
Mysql存储小数的时候, 大多数和金额有关系. 可以直接转换成分,以其作为整数形式来统计,最好别用浮点数,如果要用就要注意精度问题.
Float和Double存在精度的问题, 所以首选还是要用 Decimal和Numeric, 就我个人而Numeric用的比较多



##### 79: mysql中int, bigint, smallint和tinyint的区别与长度的含义
A : **之间的差别在于可以表示的范围(存储空间), 不同表示范围肯定占用不同长度的存储空间**
**bigint** : 从 -2^63 (-9223372036854775808) 到 2^63-1 (9223372036854775807) 的整型数据（所有数字）. **存储大小为 8 个字节**.
**int** : 从 -2^31 (-2,147,483,648) 到 2^31 – 1 (2,147,483,647) 的整型数据（所有数字）. **存储大小为 4 个字节**. int 的 SQL-92 同义字为 integer. 
**smallint** : 从 -2^15 (-32,768) 到 2^15 – 1 (32,767) 的整型数据. **存储大小为 2 个字节**. 
**tinyint** : 从 0 到 255 的整型数据. **存储大小为 1 字节**. 
int(M) 在 integer 数据类型中, M 表示最大显示宽度. 在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系. 和数字位数也无关系 int(3), int(4), int(8) 在磁盘上都是占用 4 btyes 的存储空间. 在mysql建表中的length, 只是用于显示的位数.



##### 80 : mybatis中的CURD操作方式和命名方式
A : 主要集中在两点上面, 一个在insert, **insert的时候要构造一个对象, Update的时候不要构造对象**,使用常规的参数即可. 关于函数的命名方式, insert, updateById, selectById, selectByName, deleteById, deleteByMobile这种, **将操作和字段使用By连接起来**, 也就是采用**操作-By-字段**的方式命名, 然后首字母大写即可.
:one: : **insert**语句, insert语句最好使用对象的方式来插入, 而不是使用一个一个单独的参数去完成一条记录的插入
```java
//DAO层的Mapper接口之中insert的写法
@Insert("INSERT INTO recommend_mobile(user_id, customer_name, mobile, mobile_type, status,                + amount,  reward_time, created, updated)"
		+ " VALUES (#{userId}, #{customerName}, #{mobile} #{mobileType},#{status},#{amount}, "
         + " #{rewardTime}, #{created}, #{updated})")
@Options(useGeneratedKeys = true, keyProperty = "id", keyColumn = "id")
long insert(RecommendMobile recommendMobile);//对象
```
```java
//Service层之中insert的写法
public long insert(long userId, String customerName, String mobile) {
	RecommendMobile mobileRecord = recommendMobileMapper.getByMobile(mobile);
	if (mobileRecord != null) {
		return HAVE_EXIST;
	}
	long time = TimeUtils.now();
	RecommendMobile recommendMobile = new RecommendMobile();/使用相关的参数,构造一个对象
	recommendMobile.setUserId(userId);
	recommendMobile.setCustomerName(customerName);
	recommendMobile.setMobile(mobile);
	recommendMobile.setMobileType(RecommendMobileTypeEnum.MOBILE_NO_STATUS.getCode());
	recommendMobile.setStatus(RecommendMobileRewardTypeEnum.NOT_REWARD.getCode());
	recommendMobile.setAmount(REWARD_AMOUNT);
	recommendMobile.setRewardTime(DEFAULT_REWARD_TIME);
	recommendMobile.setCreated(time);
	recommendMobile.setUpdated(time);
	recommendMobileMapper.insert(recommendMobile);
	long result = recommendMobile.getId();
	return result;
}
```
:two: : **delete**语句, delete语句是用来删除, 删除所依据的字段需要唯一, 命名采用deleteById, deleteByMobile即可, 在**Mapper层和Service层以及Controller层的调用方式是一致的**.
:three: : **update**语句, update语句用来更新一条记录, 命名方式采用updateById, updateByMobile即可, update使用的时候, 不必构造对象, 因为我们更新的时候, 大多数时候不会全字段更新,*如果构造对象的话, 就会导致有很多的字段是null值*, 所以我们**直接使用传入的基本参数即可, 而不必构造对象更新**.
```java
//DAO层的Mapper接口之中update的写法
@Update("UPDATE recommend_mobile_reward_rule SET amount = #{amount}, updated = #{updated} WHERE id = #{id}")
int updateById(@Param("amount") int amount, @Param("updated") long updated, @Param("id") int id);
```
```java
//Service层之中update的写法
public int updateById(int amount, int id) {
	RecommendMobileRewardRule tempRule = getByIdOrTypeId(id, null);// 不使用mobileType
	if (tempRule == null) return NOT_EXIST;// 没有对应的奖励规则
	long time = TimeUtils.now();// 只能修改某种套餐的amount,不可修改套餐的种类
	int result = recommendMobileRewardRuleMapper.updateById(amount, time, id);/* rule的字段有的是null, 应该是字段设置呢还是对象设置? */
	return result;
}
```
:four: : **select**语句, select语句是我们使用最多的语句, 有大量的查询, 我们得到的数据, 通常需**要使用对象,或者对象的列表来承接**,如`Hello`, `List<Hello>`, 在Mapper层之中需要注意一下, 在service层和controller层之中的调用, 和在Mapper之中的返回值保持一致即可. 命名方面一般使用selectById, selectByMobile等即可.
```java
//DAO层的Mapper接口,查询一条,使用对象来承接
@Select("<script>"
       + " SELECT id, mobile_type, amount, created, updated  FROM recommend_mobile_reward_rule "
       + " <where>"
       + " <if test=\" id !=null \"> and id = #{id} </if>"
       + " <if test=\" mobileType !=null \"> and mobile_type = #{mobileType} </if>"
       + " </where>"
       + "</script>")
RecommendMobileRewardRule getByIdOrTypeId(@Param("id") Integer id, @Param("mobileType") Integer        mobileType);
```
```java
//DAO层的Mapper接口,查询多条,使用对象列表来承接
@Select("<script>"
        + " SELECT id, user_id, customer_name, mobile, mobile_type, status, amount, reward_time, created, updated "
        + " FROM recommend_mobile "
        + " <where>"
        + " <if test=\" userId !=null \"> and user_id = #{userId} </if>"
        + " <if test=\" status !=null \"> and status = #{status} </if>"
        + " <if test=\" id !=null \"> and id <![CDATA[ < ]]> #{id} </if>"
        + " ORDER BY id DESC LIMIT #{pageSize} "
        + " </where>"
        + "</script>")
List<RecommendMobile> getByUserIdAndStatus(@Param("userId") long userId, @Param("status") int           status,@Param("id") Long id, @Param("pageSize") int pageSize);
```



##### 81 : 项目的打包和发布
A : 说明, 之前有介绍到maven的一些操作, maven是一个构建工具, 比如同事写了一些代码(API), 为我们开发提供支持, 此时我们就可以其源代码拉取下来,然后编译,发布安装到本地的maven仓库之中, 然后我们就可以使用其提供的功能了,此时需要用到的命令是
```shell
mvn clean install -Dmaven.test.skip=true
```
当我们完成了一个功能, 需要从本地环境发布到线上测试环境或者线上生产环境的时候, 我们需要将新的war包发布到tomcat的webapps之中, 此时我们需要用到的是**打包命令**, 如下

```shell
mvn clean package -Dmaven.test.skip=true
```

![](../../img/fabu1.png)
上图是打包前, 经过打包之后, 在target就会生成我们需要的war包, targe也可能因为之前打包过而存在(无关紧要)
![](../../img/fabu2.png)
然后我们再通过FTP软件, 将我们的包上传到tomcat的webapps下面就好了.其中的oil-shop文件夹可以和旧的war包一起删除, 这是等运行起来后自动生成的class文件,当我们上传了新的war包之后, 就会有新的oil-shop文件夹生成
![](../../img/fabu3.png)

相关参考见`77 : 项目的编译, Maven编译jar包用来引用`



##### 82 : 项目的分支问题
A : 如果采用了git-flow的开发模式, master是稳定生产模式, develop是所有的开发基础, feture是特性分支, 我们所有的新的功能都在feture分支上, **当我们需要发布项目到测试环境的时候, 我们就需要将代码经过本地的环境测试没有问题了之后, 合并到develop分支, 然后打包develop分支的代码, 将其发布到tomcat;** 如果发布到正式环境, 那么久需要在确认develop分支的代码没有问题之后, 将其合并到master分支, 然后将master分支的代码打包发布到tomcat之中.



##### 83 : mybatis动态语句if的test问题
A : 如下
```java
//如下的第一个test, xxx,yyy应该是userId还是user_id?
@Select("<script>"
        + " SELECT id, user_id, customer_name, mobile, mobile_type, status, amount, reward_time, created, updated "
        + " FROM recommend_mobile "
        + " <where>"
        + " <if test=\" xxx !=null \"> and yyy = #{userId} </if>"
        + " <if test=\" status !=null \"> and status = #{status} </if>"
        + " <if test=\" id !=null \"> and id <![CDATA[ < ]]> #{id} </if>"
        + " ORDER BY id DESC LIMIT #{pageSize} "
        + " </where>"
        + "</script>")
List<RecommendMobile> getByUserIdAndStatus(@Param("userId") long userId, @Param("status") int           status,@Param("id") Long id, @Param("pageSize") int pageSize);
```

动态sql语句是为了可以灵活处理sql字段而有的一种解决方式. 我们可以从上面的注释看到问题, 其实下面已经给出了答案, 应该是userId, **因为我们所采取的的test测试, 都是针对domain类的, 所以也就是class之中的文件, 因此应该在test的条件中填写userId, 而在真正的sql语句之中, 应该是sql数据库之中的字段**. 因此, yyy处应该是user_id, 完整的语句如下

```java
" <if test=\" userId !=null \"> and user_id = #{userId} </if>"
```

上述的第3个测试语句之中的`and id <![CDATA[ < ]]> #{id}`的`<![CDATA[ < ]]> `是一个转义字符, 其中转义的是`<`小于号, 如果没有此`<![CDATA[  ]]>`, mybatis的mapper接口执行的时候就会导致参数无法正常对应绑定, 所以需要注意一下.



##### 84 : mybatis动态语句if参数调用的问题
A : 动态sql就是为了处理多种组合条件下的sql的一种方式, 比如,一个查询, 可能需要按照id, 可能需要按照typeId, 也可能有同时按照id和typeId查询的情况, 这时候如果三种情况都写, 就要三个语句, 那样很麻烦, 所以我们可以使用动态语句, test之中是测试条件, 由于测试的是参数的有无, 所以用是否为null, 如`id!=null`来判断, **由于基本类型, 如int, double等在初始化的时候jvm会给其一个默认的初始值, 所以永远不会为`null`, 所以如果有~~null需求~~的字段和测试的时候, 需要使用包装类型的定义, 如Long, Integer等**

```java
//DAO层的Mapper接口,动态查询,那么如何在servicec层和controller层调用呢?
@Select("<script>"
       + " SELECT id, mobile_type, amount, created, updated  FROM recommend_mobile_reward_rule "
       + " <where>"
       + " <if test=\" id !=null \"> and id = #{id} </if>"
       + " <if test=\" mobileType !=null \"> and mobile_type = #{mobileType} </if>"
       + " </where>"
       + "</script>")
RecommendMobileRewardRule getByIdOrTypeId(@Param("id") Integer id, @Param("mobileType") Integer mobileType);
```

```java
//service层调用动态语句
public RecommendMobileRewardRule getByIdOrTypeId(Integer id, Integer mobileType) {
	    RecommendMobileRewardRule rule = recommendMobileRewardRuleMapper.
            getByIdOrTypeId(id, mobileType);
		return rule;
}
```

由此可以看出, service层的调用其实没有什么特殊的作为, 就是按照其方法调用, 那么controller层呢?

```java
//controller层调用动态语句
@RequestMapping(value = "/getByIdOrTypeId", method = RequestMethod.GET)
@ResponseBody
public YjfJsonResult getByIdOrTypeId(Integer id, Integer mobileType) {
	// 参数检查
	if (id == null && mobileType == null) {
		return YjfJsonResult.builder().code(ResultCode.PARAMS_ERROR.val()).
            message(ResultCode.PARAMS_ERROR.msg()).build();
		}
	RecommendMobileRewardRule rewardRule = ruleService.getByIdOrTypeId(id, mobileType);
	if (rewardRule == null) {
		log.info("电话卡类型的奖励规则已经存在! id:{}, mobileType:{}", id, mobileType);
        return YjfJsonResult.builder().code(ResultCode.MOBILE_REWARD_RULE_EXIST.val())
.message(ResultCode.MOBILE_REWARD_RULE_EXIST.msg()).result(ruleService.NOT_EXIST).build();
		}
        return YjfJsonResult.builder().code(ResultCode.SUCCESS.val()).
            message(ResultCode.SUCCESS.msg()).result(rewardRule).build();
	}
```

由controller可以看出也是一样的, 其决定于如何传入的参数, 如果传入id为null那么久按照mobileType查询, 反之同理, **这是正常调用走mapper-->service-->controller的路径, 所有的调用参数都按照正常的方式调用, 采用什么参数, 由前端传入的参数自动决定**, 但是, 但是, 但是,有一种情况, 就是**可能这个使用动态语句的service方法只是为其他的方法提供支持的, 那么我们就需要在service层让别人调用, 由此可得, 当只是进行某些特殊的操作时候, 我们可以将不需要的字段设置为null 或者是test测试条件失效的条件即可**, 其实同url前端传入的方式是同理的, 只不过一个是手动, 一个是自动的, 例子如下

```java
//service层的特定调用
//插入使用mobileType, 不需要id
public int insert(int mobileType, int amount) {
	RecommendMobileRewardRule tempRule = getByIdOrTypeId(null, mobileType);//insert使用mobileType, 不需要id, 所以设置id=null
	if (tempRule != null) {
		return HAVE_EXIST;// mobileType已经存在
	}
	RecommendMobileRewardRule rule = new RecommendMobileRewardRule();
	long time = TimeUtils.now();
	rule.setMobileType(mobileType);
	rule.setAmount(amount);
	rule.setCreated(time);
	rule.setUpdated(time);
	recommendMobileRewardRuleMapper.insert(rule);
	int result = rule.getId();
	return result;
}

// 删除使用使用id, 不需要mobileType
public int deleteById(int id) {
	RecommendMobileRewardRule tempRule = getByIdOrTypeId(id, null);//delete使用id, 不需要mobileType,所以设置mobileType=null
	if (tempRule == null) return NOT_EXIST;
	int result = recommendMobileRewardRuleMapper.deleteById(id);
	return result;
}

//查询一条奖励规则使用id或者mobileType
public RecommendMobileRewardRule getByIdOrTypeId(Integer id, Integer mobileType) {
	RecommendMobileRewardRule rule = recommendMobileRewardRuleMapper.getByIdOrTypeId(id, mobileType);
	return rule;
}
```

其实说白了, **动态sql的调用,就是把需要的参数设置为正常的, 把不需要的参数设置为null**.



##### 84 : mybatis的mapper语句的@param注解使用
A : 当只有一个参数的时候可以省略@Param注解, 也可以写上,都是可以的,但是而如果有多个的参数的时候, 不能省略, 必须全部都写上,否则就会报错
```java
//无
Insert("INSERT INTO recommend_mobile_reward_rule (mobile_type, amount, created, updated )"
			+ " VALUES(#{mobileType}, #{amount}, #{created}, #{updated})")
@Options(useGeneratedKeys = true, keyProperty = "id", keyColumn = "id")
int insert(RecommendMobileRewardRule recommendMobileRewardRule);

//有
@Delete("DELETE FROM recommend_mobile_reward_rule WHERE id = #{id}")
int deleteById(@Param("id") int id);

//有
@Update("UPDATE recommend_mobile_reward_rule SET amount = #{amount}, updated = #{updated} WHERE id = #{id}")
int updateById(@Param("amount") int amount, @Param("updated") long updated, @Param("id") int id);
```



##### 85 : 再谈mybatis的分页
A : 分页很重要, 我们都知道, 分页一般都是在select的操作之中, 分页有真分页和假分页两种, 真分页使用sql语句, 假分页采用前端控制, 真分页也有一次性取出来和多次取出来的区别
SQL的分页，我们可以使用**limit**关键字或者**limit**&**offset**两个关键字组合来完成分页的实现，但是使用这两个关键字的时候是有区别的。示例如下 : 

:one: . 仅使用**limit**关键字，*limit N* : **只返回符合条件的前N条**

```sql
###### sql的数据计算是从0开始的，第1条的下标为0) #####
SELECT * FROM article_topic LIMIT 10; # 符合条件的前10条
SELECT * FROM article_topic WHERE id<100 LIMIT 10; # 符合条件的前10条,这句和上面一句的含义相同
```

:two: . 使用**limit**关键字，*limit  M , N* : **跳过M条，返回N条，从第M条开始读取**

```sql
SELECT * FROM article_topic LIMIT 2,1; # 跳过2条取出1条数据，LIMIT后面是从第2条开始读，读取1条信息，即读取第2条数据，也就是第三条
SELECT * FROM article_topic LIMIT 8,5; # 跳过8条，取出5条，从第8条开始读取
SELECT * FROM article_topic WHERE id<100 LIMIT 8,5;
```

:three: . 使用**limit**&**offset**关键字，*limit M offset N* : **跳过N条，返回M条，从第N条开始计算**

```sql
SELECT * FROM article_topic LIMIT 2 OFFSET 1; # 返回2条数据，从第1条开始计算，LIMIT后面跟的是2条数据，OFFSET后面是从第1条开始读取，即读取第2,3条
SELECT * FROM article_topic LIMIT 10 OFFSET 5; # 返回10条数据，从第5条开始计算
```
其中第:two:种和第:three:种之间的关系是相反的，最好统一使用第三种: *limit M offset N*, 返回M条（跳过N条），从第N条开始计算。[ sql 中 limit 与 limit，offset连用的区别 ](https://blog.csdn.net/AinUser/article/details/72803175),   [SQL 语句的LIMIT的用法](https://www.cnblogs.com/wangxingliu/p/3512188.html)

这是sql之中的情况, 实际情况中, **我们分页都需要order排序, 根据id或者created**, 一般情况下, 我们总是需要让最近的情况显示在我们的查询结果之中, 没有太多人对于一年之前的订单感兴趣太大的兴趣, 所以通常使用`order by created desc`, *由于id通常也是增大的*, 所以也可以使用`order by id desc`, 但是这样通常都是取得的全部的查询数据, 然后再从其中查找, 对于机器的压力比较大, 如下:

```java
@Select("SElECT id, user_id, customer_name, mobile, mobile_type, status, amount, reward_time, created, updated "
			+ " FROM recommend_mobile "
			+ " WHERE user_id= #{userId} and status= #{status} ORDER BY id DESC LIMIT #{pageSize} OFFSET #{pageStart}")
List<RecommendMobile> getByUserIdAndStatus(@Param("userId") long userId, @Param("status") int status,@Param("pageSize") int pageSize, @Param("pageStart") int pageStart);
```

所以我们需要按需索取, 通过id大小来控制, 如取id=10到20的10条, 那么就设置id<20, pageSize=10即可, 如下:

```java
@Select("SELECT id, user_id, customer_name, mobile, mobile_type, status, amount, reward_time, created, updated "
              + " FROM recommend_mobile "
              + " WHERE user_id= #{userId} and status= #{status} and id < #{id} ORDER BY id DESC LIMIT #{pageSize} ")
List<RecommendMobile> getByUserIdAndStatus(@Param("userId") long userId, @Param("status") int status, @Param("id") long id, @Param("pageSize") int pageSize);
```

但是如上, **要求我们每次都要从前端获取id的大小值, 第一次前端无法获取id的大小, 所以必须允许其为空,** 因此, 我们需要设置动态sql语句来完成, 由于id可以为null, 所以其类型由基本类型设置为包装类型, `long-->Long`, 如下:

```java
@Select("<script>"
            + " SELECT id, user_id, customer_name, mobile, mobile_type, status, amount, reward_time, created, updated "
			+ " FROM recommend_mobile "
			+ " <where>"
            + " <if test=\" userId !=null \"> and user_id = #{userId} </if>"
            + " <if test=\" status !=null \"> and status = #{status} </if>"
            + " <if test=\" id !=null \"> and id <![CDATA[ < ]]> #{id} </if>"
            + " ORDER BY id DESC LIMIT #{pageSize} "
            + " </where>"
            + "</script>")
List<RecommendMobile> getByUserIdAndStatus(@Param("userId") long userId, @Param("status") int status, @Param("id") Long id, @Param("pageSize") int pageSize);//第一次id为空,也可以查询
```

这是mapper文件中的操作,  在service层正常调用即可, 如下:

```java
public List<RecommendMobile> getByUserIdAndStatus(long userId, int status, Long id, int pageSize) {
		return recommendMobileMapper.getByUserIdAndStatus(userId, status, id, pageSize);
}//只需要每页的大小pageSize, 不需要所有的都出现, 也就不需要使用offset
```

第二个关键在于controller层, 我们第一次不需要id值, 后面每次需要获取前一次的id, 作为`id < #{id}`的判断条件, 而且可以返回是否是分页的最后一次了, id通过`list.get(list.size()-1).getId()`l就可以得到, 然后就可以使用list的大小和pageSize来判断, 如果`list.size()< pageSize`那么就是最后的分页, 至于相等的情况, 可能需要多一次的获取和判断, 这个问题不大. 如下:

```java
@RequestMapping(value = "/getByUserStatus", method = RequestMethod.GET)
@ResponseBody
public YjfJsonResult getByUserIdAndStatus(int status, Long id, int pageSize) {
	long userId = SessionContextHolder.getUserId();
	if (userId < 0 || pageSize <= 0 || (id != null && id <= 0)) {
			log.warn("参数不符合要求! userId:{}, status:{}, id:{} ,pageSize:{}", userId, status, id, pageSize);
			return YjfJsonResult.builder().code(ResultCode.PARAMS_ERROR.val()).
                message(ResultCode.PARAMS_ERROR.msg())
					.build();
	}
	List<RecommendMobile> mobileList = recommendMobileService.getByUserIdAndStatus(userId, status, id, pageSize);
		HashMap<String, Object> jsonMap = new HashMap<>();
		jsonMap.put("record", mobileList);
		jsonMap.put("lastId", mobileList.get(mobileList.size() - 1).getId());// 获取最后一个的Id
		boolean end = false;
		if (mobileList.size() < pageSize) {
		end = true;
		}
		jsonMap.put("end", end);// 是否还需要分页,使用当前页的数量和pageSize来分区
		JSONObject json = new JSONObject(jsonMap);
		return YjfJsonResult.builder().code(ResultCode.SUCCESS.val()).
            message(ResultCode.SUCCESS.msg()).result(json).build();
	}
```

上面是不使用分页辅助类的的情况, 如下是使用辅助类的情况

```java
@RequestMapping(value = "/getByUserStatus", method = RequestMethod.GET)
@ResponseBody
public YjfJsonResult getByUserIdAndStatus(int status, Long id, int pageSize) {
	long userId = SessionContextHolder.getUserId();
	if (userId < 0 || pageSize <= 0 || (id != null && id <= 0)) {
			log.warn("参数不符合要求! userId:{}, status:{}, id:{} ,pageSize:{}", userId, status, id, pageSize);
			return YjfJsonResult.builder().code(ResultCode.PARAMS_ERROR.val()).
                message(ResultCode.PARAMS_ERROR.msg())
					.build();
	}
	List<RecommendMobile> mobileList = recommendMobileService.getByUserIdAndStatus(userId, status, id, pageSize);
	Mbook<RecommendMobile> mobileMbook;
	if (lastId == 0) {
		mobileMbook = Mbook.result(null, "", true);
		return YjfJsonResult.builder().code(ResultCode.SUCCESS.val()).
            message(ResultCode.SUCCESS.msg()).result(mobileMbook).build();
		}
	mobileMbook = Mbook.result(mobileList, String.valueOf(mobileList.get(lastId - 1).getId()), pageSize);
		return YjfJsonResult.builder().code(ResultCode.SUCCESS.val()).
            message(ResultCode.SUCCESS.msg()).result(mobileMbook).build();
}
```

如下是`MBook`辅助类:

```java
//MBook.java
package com.yjf.domain;

import lombok.Data;
import lombok.ToString;
import org.apache.commons.collections4.CollectionUtils;

import java.util.Collections;
import java.util.List;

/**
 * Created by xushengchao 5/3.
 */
@Data
@ToString
public class Mbook<T> {
    /**
     * 记录列表
     */
    private List<T> records;
    /**
     * 分页截止ID（根据实际含义赋值，updated时间戳、价格等)
     */
    private String lastId;
    /**
     * 是否最后一页
     */
    private boolean isEnd = false;

    /**
     * 组装返回分页列表
     *
     * @param records
     * @param lastId
     * @param isEnd
     * @param <T>
     * @return
     */
    public static <T> Mbook<T> result(List<T> records, String lastId, boolean isEnd) {
        Mbook<T> mbook = new Mbook<>();
        mbook.setRecords(records);
        mbook.setLastId(lastId);
        mbook.setEnd(isEnd);
        return mbook;
    }

    /**
     * 根据返回列表参数和页码判断是否最后一个并组装参数
     *
     * @param records
     * @param lastId
     * @param pageSize
     * @param <T>
     * @return
     */
    public static <T> Mbook<T> result(List<T> records, String lastId, Integer pageSize) {
        Mbook<T> mbook = new Mbook<>();
        mbook.setRecords(records);
        mbook.setLastId(lastId);
        mbook.setEnd(CollectionUtils.isEmpty(records) || records.size() < pageSize);
        return mbook;
    }

    /**
     * 封装mbook基础信息到已有的mbook
     *
     * @param mbook
     * @param pageSize
     * @param <T>
     */
    public static <T> void handleResult(Mbook<T> mbook, List<T> records, String lastId, Integer pageSize) {
        if (mbook != null) {
            mbook.setRecords(records);
            mbook.setLastId(lastId);
            mbook.setEnd(CollectionUtils.isEmpty(records) || records.size() < pageSize);
        }
    }

    /**
     * 默认列表
     *
     * @param <T>
     * @return
     */
    public static <T> Mbook<T> getDefault() {
        Mbook<T> mbook = new Mbook<>();
        mbook.setEnd(true);
        mbook.setRecords(Collections.emptyList());
        return mbook;
    }
}
```



##### 86 : @Transactional的处理方法
A : service层处理, 事务调用事务, 在上一层之中处理异常, 异常必须要处理, 异常必须要处理, 异常必须要处理!!!
事务的处理在Spring之中需要套用调用, 即先写好一个在service之中的方法, 在这个方法之中对需要事务处理的方法进行标注, 然后当有一些可以判断或者无法判断的情况时候, 抛出异常, 抛出异常之后, 在调用此service的另一个service之中处理异常. 
如下:`RecommendMobileRewardRuleChangeService`调用`RecommendMobileRewardRuleTransactionalService`

```java
//RecommendMobileRewardRuleTransactionalService
@Service
public class RecommendMobileRewardRuleTransactionalService {
	public static final int HAVE_EXIST = -1;
	public static final int NOT_EXIST = 0;

	@Autowired
	private RecommendMobileRewardRuleMapper recommendMobileRewardRuleMapper;
	@Autowired
	private RecommendMobileRewardRuleHistoryService recommendMobileRewardRuleHistoryService;

	/*插入一条奖励规则*/
	@Transactional(rollbackFor = Exception.class)
	public int insert(int mobileType, int amount) {
		RecommendMobileRewardRule tempRule = getByIdOrTypeId(null, mobileType);// 不使用id
		if (tempRule != null) {
			return HAVE_EXIST;// mobileType已经存在
		}
		RecommendMobileRewardRule rule = new RecommendMobileRewardRule();
		long time = TimeUtils.now();
		rule.setMobileType(mobileType);
		rule.setAmount(amount);
		rule.setCreated(time);
		rule.setUpdated(time);
		recommendMobileRewardRuleMapper.insert(rule);

		// 记录操作历史
		Integer ruleId = rule.getId();
		throw new RuntimeException();
		Integer hisId = recommendMobileRewardRuleHistoryService.insert(
				RecommendMobileRewardRuleOperatedTypeEnum.OPERATED_INSERT.getCode(), ruleId, mobileType, amount);
		/* 处理findbugs, 有待优化 */
		if (ruleId <= 0 || ruleId==null || hisId <= 0 || hisId==null) {
			throw new RuntimeException();
		}
		return ruleId;
	}

	/*删除一条奖励规则*/
	@Transactional(rollbackFor = Exception.class)
	public int deleteById(int id) {
		RecommendMobileRewardRule tempRule = getByIdOrTypeId(id, null);
		if (tempRule == null) {
			return NOT_EXIST;
		}
		Integer result = recommendMobileRewardRuleMapper.deleteById(id);
		throw new RuntimeException();
		// 记录操作历史
		Integer hisId = recommendMobileRewardRuleHistoryService.insert(
				RecommendMobileRewardRuleOperatedTypeEnum.OPERATED_DELETE.getCode(), id, tempRule.getMobileType(),
				tempRule.getAmount());
		/* 处理findbugs, 有待优化 */
		if (result <= 0 || result==null || hisId <= 0 || hisId==null) {
			throw new RuntimeException();
		}
		return result;
	}

	/* 更新一条奖励规则*/
	@Transactional(rollbackFor = Exception.class)
	public int updateById(int amount, int id) {
		RecommendMobileRewardRule tempRule = getByIdOrTypeId(id, null);// 不使用mobileType
		if (tempRule == null) {
			return NOT_EXIST;// 没有对应的奖励规则
		}
		long time = TimeUtils.now();// 只能修改某种套餐的amount,不可修改套餐的种类
		Integer result = recommendMobileRewardRuleMapper.updateById(amount, time, id);
		throw new RuntimeException();
		// 记录操作历史
		Integer hisId = recommendMobileRewardRuleHistoryService.insert(
				RecommendMobileRewardRuleOperatedTypeEnum.OPERATED_UPDATE.getCode(), id, tempRule.getMobileType(),
				tempRule.getAmount());
		/* 处理findbugs, 有待优化 */
		if (result <= 0 || result==null || hisId <= 0 || hisId==null) {
			throw new RuntimeException();
		}
		return result;
	}

	/*查询一条奖励规则使用id或者type*/
	public RecommendMobileRewardRule getByIdOrTypeId(Integer id, Integer mobileType) {
		RecommendMobileRewardRule rule = recommendMobileRewardRuleMapper.getByIdOrTypeId(id, mobileType);
		return rule;
	}
}
```

```java
//RecommendMobileRewardRuleChangeService调用RecommendMobileRewardRuleTransactionalService
@Service
@Slf4j
public class RecommendMobileRewardRuleChangeService {
	public static final int ERROR_NUMBER = -2;

	@Autowired
	RecommendMobileRewardRuleTransactionalService ruleTransactionalService;

	public int insert(int mobileType, int amount) {
		try {//处理异常
			int result = ruleTransactionalService.insert(mobileType, amount);
			return result;
		} catch (Exception e) {
			log.error("RecommendMobileRewardRuleTransactionalService：mobileType:{}, amount:{}", mobileType, amount, e);
			return ERROR_NUMBER;
		}
	}

	public int deleteById(int id) {
		try {//处理异常
			int result = ruleTransactionalService.deleteById(id);
			return result;
		} catch (Exception e) {
			log.error("RecommendMobileRewardRuleTransactionalService：id:{}", id, e);
			return ERROR_NUMBER;
		}
	}

	public int updateById(int amount, int id) {
		try {//处理异常
			int result = ruleTransactionalService.updateById(amount, id);
			return result;
		} catch (Exception e) {
			log.error("RecommendMobileRewardRuleTransactionalService：amount:{}, id:{}", amount, id, e);
			return ERROR_NUMBER;
		}
	}
}
```
在Controller之中, 最好对异常情况有明确的处理, 打日志, 输出相关参数等, 按照返回码给前端返回code, result等
```java
//RecommendMobileRewardRuleController
@RestController
@RequestMapping("recommendmobile")
@Slf4j
public class RecommendMobileRewardRuleController {
	@Autowired
	RecommendMobileRewardRuleTransactionalService ruleService;
	@Autowired
	RecommendMobileRewardRuleChangeService ruleChangeService;

	@RequestMapping(value = "/insertRule", method = RequestMethod.POST)
	@ResponseBody
	public YjfJsonResult insert(int mobileType, int amount) {
		// mobileType是unique的
		int result = ruleChangeService.insert(mobileType, amount);
		if (result == RecommendMobileRewardRuleTransactionalService.HAVE_EXIST) {
			log.info("电话卡类型的奖励规则已经存在! mobileType:{}", mobileType);
			return YjfJsonResult.builder().code(ResultCode.MOBILE_TYPE_EXIST.val())
					.message(ResultCode.MOBILE_TYPE_EXIST.msg()).result(result).build();
		}
		// 异常情况的处理
		if (result == RecommendMobileRewardRuleChangeService.ERROR_NUMBER) {
			return YjfJsonResult.builder().code(ResultCode.EXCEPTION.val()).
                message(ResultCode.EXCEPTION.msg()).build();
		}
		return YjfJsonResult.builder().code(ResultCode.SUCCESS.val()).
            message(ResultCode.SUCCESS.msg()).result(result).build();
	}

	/* 删除一条奖励规则 */
	@RequestMapping(value = "/deleteRule", method = RequestMethod.GET)
	@ResponseBody
	public YjfJsonResult deleteById(int id) {
		int result = ruleChangeService.deleteById(id);
		if (result == RecommendMobileRewardRuleTransactionalService.NOT_EXIST) {
			log.info("电话卡类型的奖励规则不存在! id:{} ", id);
			return YjfJsonResult.builder().code(ResultCode.MOBILE_REWARD_RULE_EXIST.val())
					.message(ResultCode.MOBILE_REWARD_RULE_EXIST.msg()).
                result(ruleService.NOT_EXIST).build();
		}
		// 异常情况的处理
		if (result == RecommendMobileRewardRuleChangeService.ERROR_NUMBER) {
			return YjfJsonResult.builder().code(ResultCode.EXCEPTION.val()).
                message(ResultCode.EXCEPTION.msg()).build();
		}
		return YjfJsonResult.builder().code(ResultCode.SUCCESS.val()).
            message(ResultCode.SUCCESS.msg()).result(result)
				.build();
	}

	@RequestMapping(value = "/updateRule", method = RequestMethod.POST)
	@ResponseBody
	public YjfJsonResult updateById(int amount, int id) {
		int result = ruleChangeService.updateById(amount, id);
		if (result == RecommendMobileRewardRuleTransactionalService.NOT_EXIST) {
			log.info("电话卡类型的奖励规则不存在! amount:{}, id:{} ", amount, id);
			return YjfJsonResult.builder().code(ResultCode.MOBILE_REWARD_RULE_EXIST.val())
					.message(ResultCode.MOBILE_REWARD_RULE_EXIST.msg()).
                result(ruleService.NOT_EXIST).build();
		}
		// 异常情况的处理
		if (result == RecommendMobileRewardRuleChangeService.ERROR_NUMBER) {
			return YjfJsonResult.builder().code(ResultCode.EXCEPTION.val()).
                message(ResultCode.EXCEPTION.msg()).build();
		}
		return YjfJsonResult.builder().code(ResultCode.SUCCESS.val()).
            message(ResultCode.SUCCESS.msg()).result(result).build();
	}
}
```
也就是说，事务是一个service来调用另一个service，而不是在一个service之中完成。**还需要注意，Transaction**的粒度，事务是由多个的动作组成的，一般每次只是关注一个操作，多个操作组成一个失误，然后给出操作的结果。



##### 87 : @Transactional的测试方法
A : 实际上比较简单, 只需要在我们添加了@Transactional注解的方法中抛出一个异常, 即可.示例如下:
```java
//RecommendMobileRewardRuleTransactionalService
@Service
public class RecommendMobileRewardRuleTransactionalService {
	public static final int HAVE_EXIST = -1;
	public static final int NOT_EXIST = 0;

	@Autowired
	private RecommendMobileRewardRuleMapper recommendMobileRewardRuleMapper;

	@Autowired
	private RecommendMobileRewardRuleHistoryService recommendMobileRewardRuleHistoryService;

	/*插入一条奖励规则*/
	@Transactional(rollbackFor = Exception.class)
	public int insert(int mobileType, int amount) {
		RecommendMobileRewardRule tempRule = getByIdOrTypeId(null, mobileType);// 不使用id
		if (tempRule != null) {
			return HAVE_EXIST;// mobileType已经存在
		}

		RecommendMobileRewardRule rule = new RecommendMobileRewardRule();
		long time = TimeUtils.now();
		rule.setMobileType(mobileType);
		rule.setAmount(amount);
		rule.setCreated(time);
		rule.setUpdated(time);
		recommendMobileRewardRuleMapper.insert(rule);

		// 记录操作历史
		Integer ruleId = rule.getId();
		throw new RuntimeException();//抛出一个异常, 来打断事务
        //下面的代码已经跑不了了, 所以注释掉
//		Integer hisId = recommendMobileRewardRuleHistoryService.insert(
//				RecommendMobileRewardRuleOperatedTypeEnum.OPERATED_INSERT.getCode(), ruleId, mobileType, amount);
//		// 判断 StringUtils.equals(String.valueOf(ruleId),"null");
//		if (ruleId <= 0 || StringUtils.equals(String.valueOf(ruleId), "null") || hisId <= 0
//				|| StringUtils.equals(String.valueOf(hisId), "null")) {
//			throw new RuntimeException();
//		}
//		return ruleId;
	}
}
```



##### 88: Java四种访问权限的范围与继承关系
代码继承和包结构如下
```shell
packageM
|
|- - - A
|- - - B
|- - - E
|- - - F extends E
|- - - packageN
|- - - |
|- - - |- - - C extends A
|- - - |- - - D
```
**访问控制情况**
|               | 同一个类 | 同一个包 | 不同包的子类 | 不同包的非子类 |
| ------------- | -------- | -------- | ------------ | -------------- |
| public        | √        | √        | √            | √              |
| protected     | √        | √        | √            |                |
| 默认(default) | √        | √        |              |                |
| private       | √        |          |              |                |

> Tips：其中private和protected不能修饰一般的类，否则编译就会报“modifier private not allowed here”，如果是内部类就另当别论了）

**默认(friendly)权限**
1. 类A和类D**不在同一个包**之中, 类A无法访问类D的友好字段和方法, 类A**只能访问**类D的public字段和方法, 反之亦然.
2. 类A和类B在**同一个包**之中, 类A可以访问类B的友好字段和方法,  反之亦然.

继承的几个问题
1. 继承extends与类所在包的层级无关系, 即和包的位置无直接关系, 间接关系见第3条;
2. 继承的子类可以访问父类的public, protected类型的方法, 不可以访问默认(友好), private的方法,
   可以访问public, protected的字段, 不可以访问默认(友好), private的字段;
3. 继承和默认权限之间的重叠点在于**当父类和子类处于同一个包的时候**, *可以访问其友好字段或方法的, 不在同一个包的时候不可以访问友好的字段和方法*.

**默认(friendly)权限和继承的关键点**
简言之:
默认(友好)管到包的级别,只要是同一个包里面的,既可以访问到友好以上级别的方法和字段;
继承管到protected级别,只要是子类继承了父类,子类就可以访问父类protected级别以上的方法和字段.



##### 89: 处理findbugs的Integer的Null
A : 一般情况下, 我们使用`Integer a; if(a==null)`这种方式比较, 但是有时候会报错(见86@Transactional的处理方法的`RecommendMobileRewardRuleTransactionalService`之中的方法), 因为包装类型都可以允许null值的存在, 所以这是一个需要注意的点, 为了避免,可以使用`StringUtils.equals(String.valueOf(XXX),"null");`来比较, 如下:

```java
	/* 删除一条奖励规则*/
	@Transactional(rollbackFor = Exception.class)
	public int deleteById(int id) {
		RecommendMobileRewardRule tempRule = getByIdOrTypeId(id, null);
		if (tempRule == null) {
			return NOT_EXIST;
		}
		Integer result = recommendMobileRewardRuleMapper.deleteById(id);
		throw new RuntimeException();
		// 记录操作历史
		Integer hisId = recommendMobileRewardRuleHistoryService.insert(
			    RecommendMobileRewardRuleOperatedTypeEnum.OPERATED_DELETE.getCode(), 
                 id, tempRule.getMobileType(), tempRule.getAmount());
		// 判断, 判断 StringUtils.equals(String.valueOf(result),"null");
		if (result <= 0 || StringUtils.equals(String.valueOf(result), "null") || hisId <= 0
				|| StringUtils.equals(String.valueOf(hisId), "null")) {
			throw new RuntimeException();
		}
		return result;
	}
```



##### 90 : FindBugs EI_EXPOSE_REP EI_EXPOSE_REP2
A : 提示信息：

EI: May expose internal representation by returning reference to mutable object (EI_EXPOSE_REP) 

Returning a reference to a mutable object value stored in one of the object’s fields exposes the internal representation of the object. If instances are accessed by untrusted code, and unchecked changes to the mutable object would compromise security or other important properties, you will need to do something different. Returning a new copy of the object is better approach in many situations. 

EI：可以通过返回对可变对象的引用来公开内部表示 

返回对存储在对象的一个字段中的可变对象值的引用会公开对象的内部表示。如果不受信任的代码访问实例，并且对可变对象的未经检查的更改会危及安全性或其他重要属性。在许多情况下，返回对象的新副本是更好的方法。

原代码：

```java
    /**
     * 获取：创建时间
     */
    public Date getGmtCreate() {
        return gmtCreate;
    }
```

修改后代码：

```java
    /**
     * 获取：创建时间
     */
    public Date getGmtCreate() {
        if (this.gmtCreate != null) {
            return new Date(this.gmtCreate.getTime());
        } else {
            return null;
        }
    }
```

提示信息：

EI2: May expose internal representation by incorporating reference to mutable object (EI_EXPOSE_REP2) 

This code stores a reference to an externally mutable object into the internal representation of the object. If instances are accessed by untrusted code, and unchecked changes to the mutable object would compromise security or other important properties, you will need to do something different. Storing a copy of the object is better approach in many situations. 

EI2：可以通过引用可变对象来公开内部表示 

此代码将对外部可变对象的引用存储到对象的内部表示中。如果不受信任的代码访问实例，并且对可变对象的未经检查的更改会危及安全性或其他重要属性。在许多情况下，存储对象的副本是更好的方法。

原代码：

```java
    /**
     * 设置：创建时间
     */
    public void setGmtCreate(Date gmtCreate) {
        this.gmtCreate = gmtCreate;
    }
```

修改后代码：

```java
    /**
     * 设置：创建时间
     */
    public void setGmtCreate(Date gmtCreate) {
        if (gmtCreate != null) {
            this.gmtCreate = (Date) gmtCreate.clone();
        } else {
            this.gmtCreate = null;
        }
    }
```



##### 91 : Redis的数据类型
A : 如下

|      类型       | 作用                                                         |
| :-------------: | ------------------------------------------------------------ |
| 字符串(String)  | Redis值的最基础的类型. Redis字符串是二进制安全的, 这意味着一个Redis字符串可以包含任何种类的数据, 例如一个JPEG图像或者一个序列化的Ruby对象. 一个字符串值最多可以保存512M字节的内容. |
|  散列类(hash)   | hash类型与Java中的HashMap相似，是一组键值对的集合，且支持单独对其中一个键进行增删改查操作 |
|   列表(list)    | 一个列表可以包含一个或一个以上的数量的项（item, list是有序的, **每个项按照它们被推入到列表的位置来排列** |
|    集合(Set)    | Redis的集合**以无序的方式储存**多个各不相同的元素. 用户可以快速的地向集合添加元素, 或者从集合里面删除元素, 也可以对多个集合进行集合运算操作, 比如计算并集, 交集和差集. |
| 有序集合(zset)  | 和集合一样，都可以包含任意数量的、各不相同的元素(element), 不同于集合的是, 有序集合的每个元素都关联着一个浮点数格式的分值(score), 并且有序集合会按照分值, 以从小到大的顺序来排列有序集合中的各个元素. 虽然有序集合中的每个元素都必须是各不相同的, 但元素的分值并没有这一限制, 换句话来说, 两个不同元素的分值可以是相同的 |
| HyperLogLog类型 | Redis在2.8.9版本添加了 HyperLogLog结构. 基数: 集合中不同元素的数量. 比如 {'java',  'C#',  'ruby',  'C#',  'java'}的基数就是3, 估算值: 算法给出的基数并不是精确的, 可能会比实际稍微多一些或者稍微少一些, 但会控制在合理的范围之内 |
|   GEO地理位置   | Redis的GEO特性将在 Redis 3.2 版本推出, 这个功能可以将用户给定的地理位置信息储存起来,并对这些信息进行操作 |



##### 92 : JSON字符串与JSON对象的区别
A : 如下, **二者的区别在于定义时的{}之外有无引号, 有引号则为字符串, 无引号则为对象**

**JSON对象是直接可以使用JQuery操作的格式**, 和js中的对象一样, 可以用对象(类名)点出属性(方法).
**JSON字符串仅仅只是一个字符串**, 一个整体, 不截取的话没办法取出其中存储的数据, 不能直接使用, 除非你只想alert()他.
JSON对象:
```json
var str2 = { "name": "haorooms", "sex": "man" };
```
JSON字符串:
```json
var str1 = '{ "name": "haorooms", "sex": "man" }';//最外层的引号
```



##### 93 : JSON字符串与JSON对象的转换
###### JSON字符串转换为JSON对象
要运用上面的str1, 必须运用下面的要领先转化为JSON对象(这一点在ajax返回的时候, 经常遇到!):
```json
//由JSON字符串转换为JSON对象
var obj = eval('(' + str + ')');
```

或者
```json
var obj = str.parseJSON(); //由JSON字符串转换为JSON对象
```

或者
```json
var obj = JSON.parse(str); //由JSON字符串转换为JSON对象
```

然后，就可以这样读取: 

```json
Alert(obj.name);
Alert(obj.sex);
```
特别注意：如果obj本来就是一个JSON对象，那么运用 eval()函数转换后(哪怕是多次转换)还是JSON对象，但是运用 parseJSON()函数处理后会有疑问(抛出语法异常).


###### JSON对象转化为JSON字符串
可以运用 toJSONString()或者全局方法JSON.stringify()将JSON对象转化为JSON字符串
例如: 
```json
var last=obj.toJSONString(); //将JSON对象转化为JSON字符
```
或者
```json
var last=JSON.stringify(obj); //将JSON对象转化为JSON字符
alert(last);
```
上面的多个要领中, 除了eval()函数是js自带的之外, 其他的多个要领都来自json.js包. 新版本的 JSON 修改了 API, 将 JSON.stringify() 和 JSON.parse() 两个要领都注入到了 Javascript 的内建对象里面, 前者变成了 Object.toJSONString(), 而后者变成了 String.parseJSON(). 如果提示找不到toJSONString()和parseJSON()要领, 则说明您的json包版本太低.



##### 94 : IDEA配置每个类的JVM参数
A : ![](../../img/classjvm.png)



##### 95 : mysql数据类型与java类型对应关系
A : 如下

| **类型名称**         | **显示长度** | **数据库类型**            | **JAVA类型**             | **JDBC类型索引(int)** |
| -------------------- | ------------ | ------------------------- | ------------------------ | --------------------- |
| VARCHAR          | L+N      | VARCHAR               | java.lang.String     | 12                |
| CHAR             | N        | CHAR                  | java.lang.String     | 1                 |
|**BLOB**             | **L+N**      | **BLOB**                  | **java.lang.byte[]** | **-4**                |
| **TEXT**             | **65535**    | **VARCHAR**               | **java.lang.String**     | **-1**                |
| **INTEGER**          | **4**        | **INTEGER UNSIGNED**      | **java.lang.Long**       | **4**                 |
| **TINYINT**          | **3**        | **TINYINT UNSIGNED**      | **java.lang.Integer**    | **-6**                |
| **SMALLINT**         | **5**        | **SMALLINT UNSIGNED**     | **java.lang.Integer**    | **5**                 |
| **MEDIUMINT**        | **8**        | **MEDIUMINT UNSIGNED**    | **java.lang.Integer**    | **4**                 |
| **BIT**              | **1**        | **BIT**                   | **java.lang.Boolean**    | **-7**                |
| **BIGINT**           | **20**       | **BIGINT UNSIGNED**       | **java.math.BigInteger** | **-5**                |
| FLOAT            | 4+8      | FLOAT                 | java.lang.Float      | 7                 |
| DOUBLE           | 22       | DOUBLE                | java.lang.Double     | 8                 |
| **DECIMAL**(NUMERIC) | **11**       | **DECIMAL**               | **java.math.BigDecimal** | **3**                 |
| BOOLEAN          | 1        | 同TINYINT             |                          |                       |
| **ID**               | **11**       | **PK (INTEGER UNSIGNED)** | **java.lang.Long**       | **4**                 |
| **DATE**             | **10**       | **DATE**                  | **java.sql.Date**        | **91**                |
| **TIME**             | **8**        | **TIME**                  | **java.sql.Time**        | **92**                |
| **DATETIME**         | **19**       | **DATETIME**              | **java.sql.Timestamp**   | **93**                |
| **TIMESTAMP**        | **19**       | **TIMESTAMP**             | **java.sql.Timestamp**   | **93**                |
| **YEAR**             | **4**        | **YEAR**                  | **java.sql.Date**        | **91**                |



##### 96 : Java通过子类对象调用父类已经被重写的方法
A : 子类重写父类的方法, 如果子类还要调用父类的方法, 需要使用super, super调用要在方法之中的第一行. 但是不能直接使用子类对象去调用父类的方法, 应该如下操作: **如果子类重写了父类的方法, 不能直接通过子类对象去访问父类的方法, 而需要重新创建一个调用父类方法的方法, 然后通过子类的对象去调用这个父类的方法, 达到调用父类对象的效果**. 示例如下
```java
public class baidu extends Search {
	public static void main(String[] args) throws IOException {
		new baidu().superFunction() ;
	}

	public void function(){
		System.out.println("I am baidu!");
	}
	
    /**
     *子类对象可以调用此方法,就相当于调用了父类的方法, 但是子类对象无法直接调父类的之中被子类重写的方法
     */
	public void superFunction(){
		super.function() ;
	}
}

class Search{
	public void function(){
		System.out.println("I am search!");
	}
}
```



##### 97 : BigNumber的定义, 比较和加减乘除等基本操作
```java
import java.math.BigDecimal;
import java.math.BigInteger;

public class BigNumber {
    //BigDecimal浮点大数,BigInteger整数大数
    public static void main(String[] args) {
        //1.大数字的定义
        BigDecimal bd1 = new BigDecimal("1");
        BigDecimal bd2 = new BigDecimal("1234");
        System.out.println(bd1 + ", " + bd2);
        System.out.println("0:" + BigDecimal.ZERO);
        System.out.println("1:" + BigDecimal.ONE);
        //2.大数字的比较
        /*比较结果是-1, 0, 1 表示比较的数字和compareTo的数字分别是小于,等于和大于*/
        int num1 = bd1.compareTo(bd2);
        int num2 = bd1.compareTo(BigDecimal.ZERO);
        System.out.println(bd1 + ">" + bd2 + ":" + num1);
        System.out.println(bd1 + ">" + BigDecimal.ZERO + ":" + num2);
        //3.大数字的加减乘除(除需要注意精度)
        BigInteger bi1 = new BigInteger("123");
        BigInteger bi2 = new BigInteger("543");
        BigInteger biadd = bi1.add(bi2);// +
        BigInteger bisub = bi1.subtract(bi2);// -
        BigInteger bimul = bi1.multiply(bi2);// *
        BigInteger bidiv = bi2.divide(bi1);// /
        System.out.println("+: " + biadd + "," + '\t' + "-: " + bisub + "," + '\t' + "*: " + bimul + "," + '\t' + "/: " + bidiv);
        //4.转换
        Integer a = 3;
        BigInteger b = BigInteger.valueOf(a);//int(Integer)--->BigInteger, BigDecimal同
        boolean s1 = "a" instanceof String;
        boolean s2 = b instanceof BigInteger;
        //boolean s2 = a instanceof String; 如果a是String, 是否只能instanceof String? 其他的类型不可以?
        System.out.println(b + "," + s2);
    }
}
```

结果如下:

```shell
1, 1234
0:0
1:1
1>1234:-1
1>0:1
+: 666,	-: -420,	*: 66789,	/: 4
3,true

Process finished with exit code 0
```



##### 98 : 三目运算符和instanceof运算符
```java
public class ThreeOperator {
    public static boolean isOkay(int a, int b) {
        // 如果a>b则返回true, 否则返回false
        return a > b ? true : false;
    }

    public static void main(String[] args) {
        //调用三目运算符
        System.out.println(isOkay(10, 9));

        //使用instanceof运算符
        ThreeOperator s1 = new ThreeOperator();
        boolean sss = s1 instanceof String;//如果s1是String, 是否只能instanceof String? 其他的类型不可以?
        System.out.println(sss);
    }
}
```



##### 99 : equals() 与 == 和hashcode之间的关系
A : 先看一下二者的功效

**equals()**: 作用是用来判断**两个对象**是否相等, equals()定义在JDK的Object.java中. 通过**判断两个对象的地址是否相等**(*即是否是同一个对象*)来区分它们是否相等. 源码如下: 
```java
public boolean equals(Object obj) {
    return (this == obj);
}
```
既然Object.java中定义了equals()方法, 这就意味着所有的Java类都实现了equals()方法, 所有的类都可以通过equals()去比较两个对象是否相等. **但是, 使用默认的"equals()"方法, 等价于"=="方法**. 因此, 我们通常会重写equals()方法 : 若两个对象的内容相等, 则equals()方法返回true; 否则, 返回fasle.  当未覆盖类的equals()方法时, equals()方法等价于"=="(***判断两个对象的地址是否相等***), 当我们覆盖类的equals()方法, *自定义equals()方法*, 通过其它方式比较两个对象是否相等. **通常的做法是 : 若两个对象的内容相等, 则equals()方法返回true; 否则, 返回fasle**.

**==** : 判断**两个对象的地址**是不是相等. 即, 判断两个对象是不是同一个对象, 在不在同一个地址上面, 这个我们没有办法改写, 所以我们要重写的话只能重写equals()方法. 对于基本类型, 这些是可以不用在乎的, 都是相等的.

**hashCode()**: 作用是**获取哈希码**, 也称为散列码, 它实际上是返回一个int整数. 这个**哈希码的作用**是确定该对象在哈希表中的索引位置. hashCode()定义在JDK的Object.java中, 这就意味着Java中的任何类都包含有hashCode() 函数. 虽然, 每个Java类都包含hashCode() 函数, 但仅仅当创建并某个"**类的散列表**"(*可以理解为创建列表, 链表, 集合等*)时, 该类的hashCode() 才有用(作用是确定该类的每一个对象在散列表中的位置; 其它情况下(例如, 创建类的单个对象, 或者创建类的对象数组等等), 类的hashCode() 没有作用.
**哈希码的作用**是确定该对象在哈希表中的索引位置, 为equals()/==比较创造条件.

> 上面的**散列表**, 指的是: Java集合中本质是散列表的类, 如HashMap, Hashtable, HashSet等的类. 也就是说: **hashCode() 在散列表中才有用, 在其它情况下没用. **在散列表中hashCode() 的作用是获取对象的散列码, 进而确定该对象在散列表中的位置.
```java
public int hashCode() {
    return this.地址;//伪代码
}
```


**hashCode() 和 equals() 的关系**: 二者的关系分为两种情况, 一种是**不会创建"类对应的散列表"** 之中, 一种是**会创建"类对应的散列表"** 的类之中.

- **不会创建**"类对应的散列表"
  这里所说的"不会创建类对应的散列表"是说: 我们不会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中, 用到该类. 例如, 不会创建该类的HashSet集合. **在这种情况下, 该类的"hashCode()" 和"equals()"没有半毛钱关系的**. 这种情况下, equals() 用来比较该类的两个对象是否相等. 而hashCode() 则根本没有任何作用, 所以, 不用理会hashCode().
- **会创建**"类对应的散列表"
  这里所说的"会创建类对应的散列表"是说: 我们会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中, 用到该类. 例如, 会创建该类的HashSet集合. 也就是创建了 `HashMap<ABC> abc=new HashMap();`由hashmap包裹的对象的散列结构. 在这种情况下, 该类的"hashCode()" 和 "equals()"是有关系的: 
  -  **如果两个对象相等，那么它们的hashCode()值一定相同**. 这里的相等是指, 通过equals()比较两个对象时返回true.
  -  **如果两个对象hashCode()相等, 它们并不一定相等**. *因为在散列表中, hashCode()相等, 即两个键值对的哈希值相等*. 然而哈希值相等, 并不一定能得出键值对相等, 补充说一句: "两个不同的键值对, 哈希值相等", 这就是**哈希(地址)冲突**. 在这种情况下, 若要判断两个对象是否相等, 除了要覆盖equals()之外, 也要覆盖hashCode()函数. 否则, equals()无效.

**通常情况下, 在需要覆写equals()的时候, 都需要同时覆写hashcode(), 这样最保险**. 如下是覆写的例子 

```java
public class OverrideHashEquals {

    public static void main(String[] args) {
        JavaBook book1 = new ThinkJavaBook(2);
        System.out.println("book1 num: " + book1.getNum());
        JavaBook book2 = new ThinkJavaBook(10);
        System.out.println("book2 num: " + book2.getNum());
        ThinkJavaBook book3 = new ThinkJavaBook(2);

        System.out.println("book3 num: " + book3.getNum());
        System.out.println("book1 hashcode:" + ((ThinkJavaBook) book1).hashCode());
        System.out.println("book2 hashcode:" + ((ThinkJavaBook) book2).hashCode());
        System.out.println("book3 hashcode:" + book3.hashCode());
        if (book1.equals(book2)) {
            System.out.println("book1==book2");
        } else {
            System.out.println("book1!=book2");
        }

        if (book1.equals(book3)) {
            System.out.println("book1==book3");
        } else {
            System.out.println("book1!=book3");
        }
    }
}

class ThinkJavaBook extends JavaBook {
    ThinkJavaBook(int n) {
        super(n);
    }

    @Override
    public int hashCode() {
        //设置hashcode为num的值
        return super.getNum();
    }

    @Override
    public boolean equals(Object obj) {
        // 类型和num作为判断的标准
        if (obj instanceof ThinkJavaBook && ((ThinkJavaBook) obj).getNum() == this.getNum()) {
            return true;
        } else {
            return false;
        }
    }
}
class JavaBook {
    @Getter
    @Setter
    private int num;

    JavaBook(int n) {
        this.num = n;
    }
}
```



##### 100 : fastjson之中的基本用法
A : 如下

**创建JSON对象的时候, 就使用JSONObject来创建**, 即可.FasJSON对于json格式字符串的解析主要用到了`JSON`, `JSONObject`, `JSONArray`三个类:

**JSON**: fastJson的解析器, *用于**JSON格式字符串**与**JSON对象及javaBean**之间的转换*. **转换就用这个类**.

**JSONObjec**: fastJson提供的json对象.

**JSONArray**: fastJson提供json数组对象.

我们可以把**JSONObject当成一个Map<String,Object>**来看, 只是JSONObject提供了更为丰富便捷的方法, 方便我们对于对象属性的操作. 源码如下图.

![img](../../img/json1.png)

同样我们可以把**JSONArray当做一个List\<Object\>**, 可以把**JSONArray看成JSONObject对象**的一个集合. 源码如下图.

![img](../../img/json2.png)

此外，由于JSONObject和JSONArray继承了JSON，所以说也可以直接使用两者对JSON格式字符串与JSON对象及javaBean之间做转换, **不过为了避免混淆我们还是使用JSON**.

具体的使用见`FastJSON解析JSON.md`

###### 转换例子

1.序列化

```java
package com.cqu.rjx.utils.json.fastjson;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import lombok.Getter;
import lombok.Setter;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @Author: renjiaxin
 * @Despcription:
 * @Date: Created in 2018/8/14 10:57
 * @Modified by:
 */

/**
 * JSON序列化
 */
public class JsonSerialization {

    public static void main(String[] args) {
        /*定义JsonObject*/
        JSONObject jsonObject = new JSONObject();
        //自己初始化
        jsonObject.put("jsonObj", "我是一个json对象");
        //使用map初始化
        Map<String, Object> map1 = new HashMap<>();
        map1.put("map-fill-json", "hello, map-fill-json");
        JSONObject jsonObjectFromMap = new JSONObject(map1);

        /*定义JsonArray*/
        JSONArray jsonArray1 = new JSONArray();
        JSONArray jsonArray2 = new JSONArray(3);
        Map<String, Object> map2 = new HashMap<>();
        map2.put("map2", "map2");
        Map<String, Object> map3 = new HashMap<>();
        map3.put("map3", "map3");
        List<Map<String, Object>> list = new ArrayList<Map<String, Object>>();
        list.add(map1);
        list.add(map2);
        list.add(map3);
        jsonArray1.add(0, 123);
        jsonArray1.add(1, "hello");
        jsonArray1.add(2, "mgk");
        jsonArray2.add(list);
        //JSONArray jsonArray3 = new JSONArray(list);//现在还不可将map直接放到jsonArray之中, 没有这种类型的构造函数
        JSONArray jsonArray3 = new JSONArray(2);
        List<Map<String, Object>> list2 = new ArrayList<Map<String, Object>>();
        Map<String, Object> map4 = new HashMap<>();
        Map<String, Object> map5 = new HashMap<>();
        map4.put("hello mpa", "helllomap");
        map5.put("zgy", "zuiguangyin");
        list2.add(map4);
        list2.add(map5);
        jsonArray3.add(0, list);
        jsonArray3.add(1, list2);

        /**序列化, 将其他的格式转换成为jsonstr(json字符串),最好统一使用JSON来转换**/
        //jsonObject--->json字符串;
        System.out.println("\njsonObject--->json字符串");
        String jsonObjectStr = JSON.toJSONString(jsonObject);
        System.out.println("jsonObject的json字符串: " + jsonObjectStr);

        //jsonArray--->json字符串;
        System.out.println("\njsonArray--->json字符串");
        String jsonArrayStr1 = JSON.toJSONString(jsonArray1);
        System.out.println("jsonArrayStr1的json字符串: " + jsonArrayStr1);
        String jsonArrayStr2 = JSON.toJSONString(jsonArray2);
        System.out.println("jsonArrayStr2的json字符串: " + jsonArrayStr2);
        String jsonArrayStr3 = JSON.toJSONString(jsonArray3);
        System.out.println("jsonArrayStr3的json字符串: " + jsonArrayStr3);


        //java对象--->json字符串
        PersonJson personJson1 = new PersonJson();
        PersonJson personJson2 = new PersonJson();
        personJson1.setName("张三");
        personJson1.setAge(24);
        personJson2.setAge(29);
        personJson2.setName("junliang lee");
        System.out.println("\njava对象--->json字符串");
        String javaObjectStr1 = JSON.toJSONString(personJson1);
        System.out.println("java对象personJson1的json字符串: " + javaObjectStr1);
        String javaObjectStr2 = JSON.toJSONString(personJson2);
        System.out.println("java对象personJson2的json字符串: " + javaObjectStr2);
    }

    static class PersonJson {
        @Getter
        @Setter
        private int age;
        @Getter
        @Setter
        private String name;
    }
}
```

2.反序列化

```java
package com.cqu.rjx.utils.json.fastjson;

/**
 * @Author: renjiaxin
 * @Despcription:
 * @Date: Created in 2018/8/14 14:05
 * @Modified by:
 */

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import lombok.Getter;
import lombok.Setter;

import java.util.List;
import java.util.Map;

/**
 * JSON反序列化
 */
public class JsonDeserialization {
    public static void main(String[] args) {
        /*定义json字符串的方法*/
        /*最外面需要用双引号包围, 所有的双引号都需要用'\"'来转义, ":"冒号不需要转义,
         *定义jsonarray字符串时, 内层的[,],{,}不需要转义, 只转义"双引号
         **/

        //定义一个json的字符串
        String guanyu = "{\"name\":\"关羽\", \"age\":\"24\"}";


        //定义两个jsonArray的字符串
        String starsWest = "[{\"name\":\"justin biber\", \"age\":\"22\"}, {\"name\":\"mike\", \"age\":\"17\"}, "
                + " {\"国籍\":\"美国\"}, {\"name\":\"bulanni\",\"age\": 36, ,\"nation\":\"uk\"}]";

        String starsJapan = "[{\"name\":\"大桥未久\", \"age\":\"24\"}, {\"name\":\"天海翼\", \"age\":\"24\"}, {\"国籍\":\"日本\"}]";

        String mapKeyValue = "[{\"key1\":\"One\",\"key2\":\"Two\"},{\"key3\":\"Three\",\"key4\":\"Four\"}]";


        //定义两个java对象的字符串
        String lionAl = "{\"name\":\"非洲狮\",\"territory\":\"尼日利亚\"}";
        String lionSl = "{\"name\":\"美洲狮\",\"territory\":\"巴西\"}";


        //json字符串--->jsonObject;
        /*JSONObject相当于一个Map<String , Object>*/
        System.out.println("\njson字符串--->jsonObject");
        System.out.println("原先的json字符串: " + guanyu);
        JSONObject jsonObject1 = JSON.parseObject(guanyu);
        System.out.println("转换后获取其中的name值: " + jsonObject1.get("name"));


        //json字符串--->jsonArray;
        System.out.println("\njson字符串--->jsonArray");
        System.out.println("原先的jsonArray字符串starsWest: " + starsWest);
        System.out.println("原先的jsonArray字符串starsJapan: " + starsJapan);
        System.out.println("原先的jsonArray字符串mapKeyValue: " + mapKeyValue);

        /*JSONArray相当于JsonObject的数组, 对应的是List<Map>*/
        List<Map> jsonArray1 = JSON.parseArray(starsWest, Map.class);//转换的时候, 需要用相应的类型来盛下
        List<Map> jsonArray2 = JSON.parseArray(starsJapan, Map.class);
        List<Map> jsonArray3 = JSON.parseArray(mapKeyValue, Map.class);
        System.out.println("starsWest的情况: " + jsonArray1.get(1));
        System.out.println("starsJapan的情况: " + jsonArray2.size() + jsonArray2.get(1));
        System.out.println("mapKeyValue的情况: " + jsonArray3.size() + ", " + jsonArray3.get(1));
        // 循环获取map的值
        for (Map<String, Object> map : jsonArray2) {
            System.out.println(map.get("name"));
            System.out.println(map.get("age"));
        }

        //json字符串--->java对象
        System.out.println("\njson字符串--->java对象");
        System.out.println("原先的json字符串: " + lionAl);
        System.out.println("原先的json字符串: " + lionSl);
        Lion lionA = JSON.parseObject(lionAl, Lion.class);
        Lion lionS = JSON.parseObject(lionSl, Lion.class);
        System.out.println("转换后获取其中的name和territory值: " + lionA.getName() + ", " + lionA.getTerritory());
        System.out.println("转换后获取其中的name和territory值: " + lionS.getName() + ", " + lionS.getTerritory());

    }

    static class Lion {
        @Getter
        @Setter
        private String name;
        @Getter
        @Setter
        private String territory;//领地
    }
}
```

3.使用经验小结

> JSON的序列化和反序列化
> *JSONObject相当于一个Map\<String , Object\>*
> *JSONArray相当于JsonObject的数组, 对应的是List\<Map\>*
> 反序列化的时候, 转换的时候, 需要用相应的类型来盛下
> ###### 转换
> 1. String--->Map 和Map--->String 其实就是 json字符串str<--->json object的转换
> 2. String<--->JSONArray的转换(反序列化的时候, 转换的时候, 需要用相应的类型来盛下)
>
>     
>
> **转换的时候,一般使用JSON来操作**



##### 101 : This is very likely to create a memory leak
```shell
[2018-08-13 13:24:20.131 WARN ] [localhost-startStop-2] o.a.j.l.DirectJDKLog[180] - The web application [ROOT] appears to have started a thread named [Abandoned connection cleanup thread] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:
 java.lang.Object.wait(Native Method)
 java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)
 java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)
 com.mysql.jdbc.NonRegisteringDriver$1.run(NonRegisteringDriver.java:93)
```
A : 问题的描述如上, 具体是因为corn表达式多了一个年份, `0 */5 * * * ? *`, 就是因为?后面的 *号, 导致了以上的问题, 去掉之后即可.
**得看项目日志, 日志里面说明了详细的原因, 很多种情况都可能导致此情况, 需要注意**.



ref:
51.[mysql中decimal,numeric,double,float的区别](https://blog.csdn.net/wufaliang003/article/details/78502402),   52.[mysql 数据类型 Float、Double、Decimal和Numeric 的区别](http://www.uuboku.com/455.html),   53.[mysql中int、bigint、smallint 和 tinyint的区别与长度的含义](https://blog.csdn.net/spring21st/article/details/7332200),  54.[Java中四种访问权限总结](https://blog.csdn.net/itachiyang/article/details/43647909),   55.[FindBugs EI_EXPOSE_REP EI_EXPOSE_REP2](https://blog.csdn.net/pythonerxxs/article/details/81026322),   55.[Redis教程(1~8)](https://blog.csdn.net/yuan_xw/article/details/52084090),   56.[Redis 数据结构与内存管理策略（上）](http://blog.51cto.com/wangqingpei557/2063316),   57.[Redis 数据结构与内存管理策略（下）](http://blog.51cto.com/wangqingpei557/2065712),   58.[JSON字符串与JSON对象的区别](https://www.cnblogs.com/theWayToAce/p/7018948.html),    59.[JSON | JSON字符串和JSON对象的区别](https://www.jianshu.com/p/4b0bb59f585f),   60.[JSON字符串与JSON对象的区别](https://www.haorooms.com/post/json_object_json_string),   61.[介绍 JSON](https://www.json.org/json-zh.html),   62.[mysql decimal(10,2)对应java类型](https://blog.csdn.net/u012768459/article/details/78677899),   63.[Java 数据类型和 MySql 数据类型对应一览表](https://blog.csdn.net/defonds/article/details/46681701),   64.[java 通过子类怎么调用父类已经被重写的方法](http://www.voidcn.com/article/p-fywwtyvh-gr.html),   65.[java 通过子类怎么调用父类已经被重写的方法](https://blog.csdn.net/f330468286/article/details/8820925),   66.[BigInteger详解](https://blog.csdn.net/qfikh/article/details/52832196),   67.[instanceof运算符的使用](https://www.cnblogs.com/wxywxy/p/6740617.html),   68.[Java高新技术——大数操作（BigInteger、BigDecimal）](https://blog.csdn.net/zhongkelee/article/details/52289163),   69.[hashcode详解](https://www.cnblogs.com/whgk/p/6071617.html),   70.[Java hashCode() 和 equals()的若干问题解答](https://www.cnblogs.com/skywang12345/p/3324958.html),   71.[[转载\] 散列表(Hash Table)从理论到实用（上）](https://www.cnblogs.com/skywang12345/p/3311899.html) ,   72.[[转载\] 散列表(Hash Table)从理论到实用（中）](https://www.cnblogs.com/skywang12345/p/3311909.html) ,   73.[[转载\] 散列表(Hash Table) 从理论到实用（下）](https://www.cnblogs.com/skywang12345/p/3311915.html) ,   74.[fastjson 的使用总结](https://www.cnblogs.com/dmego/p/9033080.html),   75.[高性能JSON框架之FastJson的简单使用](https://segmentfault.com/a/1190000011212806),   76.[FastJSON 简单使用](https://www.cnblogs.com/Jie-Jack/p/3758046.html),   77.[使用JSONObject生成和解析json](https://www.cnblogs.com/joahyau/p/6736637.html),   78.[FastJson--阿里巴巴公司开源的速度最快的Json和对象转换工具](https://blog.csdn.net/djun100/article/details/24237371),   79.[使用FastJSON 对Map/JSON/String 进行互转](https://blog.csdn.net/cool_summer_moon/article/details/78722623)